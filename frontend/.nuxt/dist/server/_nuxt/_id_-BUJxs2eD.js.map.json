{"file":"_id_-BUJxs2eD.js","mappings":"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","names":["_a","_useModel","_ssrRenderAttrs","_mergeProps","_ssrRenderList","_ssrInterpolate","_unref","_ssrRenderAttr"],"sources":["../../../../node_modules/nuxt/dist/app/composables/asyncData.js","../../../../components/RatingStars.vue","../../../../pages/libro/[id].vue"],"sourcesContent":["import { computed, getCurrentInstance, getCurrentScope, inject, isShallow, nextTick, onBeforeMount, onScopeDispose, onServerPrefetch, onUnmounted, ref, shallowRef, toRef, toValue, unref, watch } from \"vue\";\nimport { captureStackTrace } from \"errx\";\nimport { debounce } from \"perfect-debounce\";\nimport { hash } from \"ohash\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nimport { clientOnlySymbol } from \"../components/client-only.js\";\nimport { createError } from \"./error.js\";\nimport { onNuxtReady } from \"./ready.js\";\nimport { asyncDataDefaults, granularCachedData, pendingWhenIdle, purgeCachedData, resetAsyncDataToUndefined } from \"#build/nuxt.config.mjs\";\nconst isDefer = (dedupe) => dedupe === \"defer\" || dedupe === false;\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (_isAutoKeyNeeded(args[0], args[1])) {\n    args.unshift(autoKey);\n  }\n  let [_key, _handler, options = {}] = args;\n  const key = computed(() => toValue(_key));\n  if (typeof key.value !== \"string\") {\n    throw new TypeError(\"[nuxt] [useAsyncData] key must be a string.\");\n  }\n  if (typeof _handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [useAsyncData] handler must be a function.\");\n  }\n  const nuxtApp = useNuxtApp();\n  options.server ??= true;\n  options.default ??= getDefault;\n  options.getCachedData ??= getDefaultCachedData;\n  options.lazy ??= false;\n  options.immediate ??= true;\n  options.deep ??= asyncDataDefaults.deep;\n  options.dedupe ??= \"cancel\";\n  const functionName = options._functionName || \"useAsyncData\";\n  if (import.meta.dev && typeof options.dedupe === \"boolean\") {\n    console.warn(`[nuxt] \\`boolean\\` values are deprecated for the \\`dedupe\\` option of \\`${functionName}\\` and will be removed in the future. Use 'cancel' or 'defer' instead.`);\n  }\n  const currentData = nuxtApp._asyncData[key.value];\n  if (isDev && currentData) {\n    const warnings = [];\n    const values = createHash(_handler, options);\n    if (values.handler !== currentData._hash?.handler) {\n      warnings.push(`different handler`);\n    }\n    for (const opt of [\"transform\", \"pick\", \"getCachedData\"]) {\n      if (values[opt] !== currentData._hash[opt]) {\n        warnings.push(`different \\`${opt}\\` option`);\n      }\n    }\n    if (currentData._default.toString() !== options.default.toString()) {\n      warnings.push(`different \\`default\\` value`);\n    }\n    if (options.deep && isShallow(currentData.data)) {\n      warnings.push(`mismatching \\`deep\\` option`);\n    }\n    if (warnings.length) {\n      const distURL = import.meta.url.replace(/\\/app\\/.*$/, \"/app\");\n      const { source, line, column } = captureStackTrace().find((entry) => !entry.source.startsWith(distURL)) ?? {};\n      const explanation = source ? ` (used at ${source.replace(/^file:\\/\\//, \"\")}:${line}:${column})` : \"\";\n      console.warn(`[nuxt] [${functionName}] Incompatible options detected for \"${key.value}\"${explanation}:\n${warnings.map((w) => `- ${w}`).join(\"\\n\")}\nYou can use a different key or move the call to a composable to ensure the options are shared across calls.`);\n    }\n  }\n  const initialFetchOptions = { cause: \"initial\", dedupe: options.dedupe };\n  if (!nuxtApp._asyncData[key.value]?._init) {\n    initialFetchOptions.cachedData = options.getCachedData(key.value, nuxtApp, { cause: \"initial\" });\n    nuxtApp._asyncData[key.value] = createAsyncData(nuxtApp, key.value, _handler, options, initialFetchOptions.cachedData);\n  }\n  const asyncData = nuxtApp._asyncData[key.value];\n  asyncData._deps++;\n  const initialFetch = () => nuxtApp._asyncData[key.value].execute(initialFetchOptions);\n  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered;\n  if (import.meta.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxtApp.hook(\"app:created\", async () => {\n        await promise;\n      });\n    }\n  }\n  if (import.meta.client) {\n    let unregister = function(key2) {\n      const data = nuxtApp._asyncData[key2];\n      if (data?._deps) {\n        data._deps--;\n        if (data._deps === 0) {\n          data?._off();\n        }\n      }\n    };\n    const instance = getCurrentInstance();\n    if (instance && fetchOnServer && options.immediate && !instance.sp) {\n      instance.sp = [];\n    }\n    if (import.meta.dev && !nuxtApp.isHydrating && !nuxtApp._processingMiddleware && (!instance || instance?.isMounted)) {\n      console.warn(`[nuxt] [${functionName}] Component is already mounted, please use $fetch instead. See https://nuxt.com/docs/getting-started/data-fetching`);\n    }\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      onBeforeMount(() => {\n        cbs.forEach((cb) => {\n          cb();\n        });\n        cbs.splice(0, cbs.length);\n      });\n      onUnmounted(() => cbs.splice(0, cbs.length));\n    }\n    const isWithinClientOnly = instance && (instance._nuxtClientOnly || inject(clientOnlySymbol, false));\n    if (fetchOnServer && nuxtApp.isHydrating && (asyncData.error.value || asyncData.data.value != null)) {\n      if (pendingWhenIdle) {\n        asyncData.pending.value = false;\n      }\n      asyncData.status.value = asyncData.error.value ? \"error\" : \"success\";\n    } else if (instance && (!isWithinClientOnly && nuxtApp.payload.serverRendered && nuxtApp.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    const hasScope = getCurrentScope();\n    const unsubExecute = watch([key, ...options.watch || []], ([newKey], [oldKey]) => {\n      if ((newKey || oldKey) && newKey !== oldKey) {\n        const hasRun = nuxtApp._asyncData[oldKey]?.data.value !== asyncDataDefaults.value;\n        if (oldKey) {\n          unregister(oldKey);\n        }\n        const initialFetchOptions2 = { cause: \"initial\", dedupe: options.dedupe };\n        if (!nuxtApp._asyncData[newKey]?._init) {\n          initialFetchOptions2.cachedData = options.getCachedData(newKey, nuxtApp, { cause: \"initial\" });\n          nuxtApp._asyncData[newKey] = createAsyncData(nuxtApp, newKey, _handler, options, initialFetchOptions2.cachedData);\n        }\n        nuxtApp._asyncData[newKey]._deps++;\n        if (options.immediate || hasRun) {\n          nuxtApp._asyncData[newKey].execute(initialFetchOptions2);\n        }\n      } else {\n        asyncData._execute({ cause: \"watch\", dedupe: options.dedupe });\n      }\n    }, { flush: \"sync\" });\n    if (hasScope) {\n      onScopeDispose(() => {\n        unsubExecute();\n        unregister(key.value);\n      });\n    }\n  }\n  const asyncReturn = {\n    data: writableComputedRef(() => nuxtApp._asyncData[key.value]?.data),\n    pending: writableComputedRef(() => nuxtApp._asyncData[key.value]?.pending),\n    status: writableComputedRef(() => nuxtApp._asyncData[key.value]?.status),\n    error: writableComputedRef(() => nuxtApp._asyncData[key.value]?.error),\n    refresh: (...args2) => nuxtApp._asyncData[key.value].execute(...args2),\n    execute: (...args2) => nuxtApp._asyncData[key.value].execute(...args2),\n    clear: () => clearNuxtDataByKey(nuxtApp, key.value)\n  };\n  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key.value]).then(() => asyncReturn);\n  Object.assign(asyncDataPromise, asyncReturn);\n  return asyncDataPromise;\n}\nfunction writableComputedRef(getter) {\n  return computed({\n    get() {\n      return getter()?.value;\n    },\n    set(value) {\n      const ref2 = getter();\n      if (ref2) {\n        ref2.value = value;\n      }\n    }\n  });\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (_isAutoKeyNeeded(args[0], args[1])) {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options = {}] = args;\n  if (import.meta.dev) {\n    options._functionName ||= \"useLazyAsyncData\";\n  }\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nfunction _isAutoKeyNeeded(keyOrFetcher, fetcher) {\n  if (typeof keyOrFetcher === \"string\") {\n    return false;\n  }\n  if (typeof keyOrFetcher === \"object\" && keyOrFetcher !== null) {\n    return false;\n  }\n  if (typeof keyOrFetcher === \"function\" && typeof fetcher === \"function\") {\n    return false;\n  }\n  return true;\n}\nexport function useNuxtData(key) {\n  const nuxtApp = useNuxtApp();\n  if (!(key in nuxtApp.payload.data)) {\n    nuxtApp.payload.data[key] = asyncDataDefaults.value;\n  }\n  if (nuxtApp._asyncData[key]) {\n    const data = nuxtApp._asyncData[key];\n    data._deps++;\n    if (getCurrentScope()) {\n      onScopeDispose(() => {\n        data._deps--;\n        if (data._deps === 0) {\n          data?._off();\n        }\n      });\n    }\n  }\n  return {\n    data: computed({\n      get() {\n        return nuxtApp._asyncData[key]?.data.value ?? nuxtApp.payload.data[key];\n      },\n      set(value) {\n        if (nuxtApp._asyncData[key]) {\n          nuxtApp._asyncData[key].data.value = value;\n        } else {\n          nuxtApp.payload.data[key] = value;\n        }\n      }\n    })\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (import.meta.server) {\n    return Promise.resolve();\n  }\n  await new Promise((resolve) => onNuxtReady(resolve));\n  const _keys = keys ? toArray(keys) : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\n  for (const key of _keys) {\n    clearNuxtDataByKey(nuxtApp, key);\n  }\n}\nfunction clearNuxtDataByKey(nuxtApp, key) {\n  if (key in nuxtApp.payload.data) {\n    nuxtApp.payload.data[key] = void 0;\n  }\n  if (key in nuxtApp.payload._errors) {\n    nuxtApp.payload._errors[key] = asyncDataDefaults.errorValue;\n  }\n  if (nuxtApp._asyncData[key]) {\n    nuxtApp._asyncData[key].data.value = resetAsyncDataToUndefined ? void 0 : unref(nuxtApp._asyncData[key]._default());\n    nuxtApp._asyncData[key].error.value = asyncDataDefaults.errorValue;\n    if (pendingWhenIdle) {\n      nuxtApp._asyncData[key].pending.value = false;\n    }\n    nuxtApp._asyncData[key].status.value = \"idle\";\n  }\n  if (key in nuxtApp._asyncDataPromises) {\n    if (nuxtApp._asyncDataPromises[key]) {\n      nuxtApp._asyncDataPromises[key].cancelled = true;\n    }\n    nuxtApp._asyncDataPromises[key] = void 0;\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\nconst isDev = import.meta.dev;\nfunction createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {\n  nuxtApp.payload._errors[key] ??= asyncDataDefaults.errorValue;\n  const hasCustomGetCachedData = options.getCachedData !== getDefaultCachedData;\n  const handler = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?._sharedPrerenderCache ? _handler : () => {\n    const value = nuxtApp.ssrContext._sharedPrerenderCache.get(key);\n    if (value) {\n      return value;\n    }\n    const promise = Promise.resolve().then(() => nuxtApp.runWithContext(() => _handler(nuxtApp)));\n    nuxtApp.ssrContext._sharedPrerenderCache.set(key, promise);\n    return promise;\n  };\n  const _ref = options.deep ? ref : shallowRef;\n  const hasCachedData = initialCachedData != null;\n  const unsubRefreshAsyncData = nuxtApp.hook(\"app:data:refresh\", async (keys) => {\n    if (!keys || keys.includes(key)) {\n      await asyncData.execute({ cause: \"refresh:hook\" });\n    }\n  });\n  const asyncData = {\n    data: _ref(hasCachedData ? initialCachedData : options.default()),\n    pending: pendingWhenIdle ? shallowRef(!hasCachedData) : computed(() => asyncData.status.value === \"pending\"),\n    error: toRef(nuxtApp.payload._errors, key),\n    status: shallowRef(\"idle\"),\n    execute: (opts = {}) => {\n      if (nuxtApp._asyncDataPromises[key]) {\n        if (isDefer(opts.dedupe ?? options.dedupe)) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        nuxtApp._asyncDataPromises[key].cancelled = true;\n      }\n      if (granularCachedData || opts.cause === \"initial\" || nuxtApp.isHydrating) {\n        const cachedData = \"cachedData\" in opts ? opts.cachedData : options.getCachedData(key, nuxtApp, { cause: opts.cause ?? \"refresh:manual\" });\n        if (cachedData != null) {\n          nuxtApp.payload.data[key] = asyncData.data.value = cachedData;\n          asyncData.error.value = asyncDataDefaults.errorValue;\n          asyncData.status.value = \"success\";\n          return Promise.resolve(cachedData);\n        }\n      }\n      if (pendingWhenIdle) {\n        asyncData.pending.value = true;\n      }\n      asyncData.status.value = \"pending\";\n      const promise = new Promise(\n        (resolve, reject) => {\n          try {\n            resolve(handler(nuxtApp));\n          } catch (err) {\n            reject(err);\n          }\n        }\n      ).then(async (_result) => {\n        if (promise.cancelled) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        let result = _result;\n        if (options.transform) {\n          result = await options.transform(_result);\n        }\n        if (options.pick) {\n          result = pick(result, options.pick);\n        }\n        if (import.meta.dev && import.meta.server && typeof result === \"undefined\") {\n          const stack = captureStackTrace();\n          const { source, line, column } = stack[stack.length - 1] ?? {};\n          const explanation = source ? ` (used at ${source.replace(/^file:\\/\\//, \"\")}:${line}:${column})` : \"\";\n          console.warn(`[nuxt] \\`${options._functionName || \"useAsyncData\"}${explanation}\\` must return a value (it should not be \\`undefined\\`) or the request may be duplicated on the client side.`);\n        }\n        nuxtApp.payload.data[key] = result;\n        asyncData.data.value = result;\n        asyncData.error.value = asyncDataDefaults.errorValue;\n        asyncData.status.value = \"success\";\n      }).catch((error) => {\n        if (promise.cancelled) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        asyncData.error.value = createError(error);\n        asyncData.data.value = unref(options.default());\n        asyncData.status.value = \"error\";\n      }).finally(() => {\n        if (promise.cancelled) {\n          return;\n        }\n        if (pendingWhenIdle) {\n          asyncData.pending.value = false;\n        }\n        delete nuxtApp._asyncDataPromises[key];\n      });\n      nuxtApp._asyncDataPromises[key] = promise;\n      return nuxtApp._asyncDataPromises[key];\n    },\n    _execute: debounce((...args) => asyncData.execute(...args), 0, { leading: true }),\n    _default: options.default,\n    _deps: 0,\n    _init: true,\n    _hash: isDev ? createHash(_handler, options) : void 0,\n    _off: () => {\n      unsubRefreshAsyncData();\n      if (nuxtApp._asyncData[key]?._init) {\n        nuxtApp._asyncData[key]._init = false;\n      }\n      if (purgeCachedData && !hasCustomGetCachedData) {\n        nextTick(() => {\n          if (!nuxtApp._asyncData[key]?._init) {\n            clearNuxtDataByKey(nuxtApp, key);\n            asyncData.execute = () => Promise.resolve();\n            asyncData.data.value = asyncDataDefaults.value;\n          }\n        });\n      }\n    }\n  };\n  return asyncData;\n}\nconst getDefault = () => asyncDataDefaults.value;\nconst getDefaultCachedData = (key, nuxtApp, ctx) => {\n  if (nuxtApp.isHydrating) {\n    return nuxtApp.payload.data[key];\n  }\n  if (ctx.cause !== \"refresh:manual\" && ctx.cause !== \"refresh:hook\") {\n    return nuxtApp.static.data[key];\n  }\n};\nfunction createHash(_handler, options) {\n  return {\n    handler: hash(_handler),\n    transform: options.transform ? hash(options.transform) : void 0,\n    pick: options.pick ? hash(options.pick) : void 0,\n    getCachedData: options.getCachedData ? hash(options.getCachedData) : void 0\n  };\n}\n","<script setup lang=\"ts\">\nconst model = defineModel<number | null>({ default: null });\nfunction set(v:number){ model.value = v; }\n</script>\n<template>\n  <div style=\"display:flex; gap:8px; font-size:24px; cursor:pointer;\">\n    <span v-for=\"n in 5\" :key=\"n\" @click=\"set(n)\">{{ (model ?? 0) >= n ? '★' : '☆' }}</span>\n  </div>\n</template>\n","<script setup lang=\"ts\">\nimport { computed, ref } from 'vue'\nimport { useRoute } from 'vue-router'\nimport { useAsyncData, useNuxtApp } from 'nuxt/app'\nimport type { $Fetch } from 'ofetch'\n\nconst $api = useNuxtApp().$api as $Fetch\nconst route = useRoute()\n\n// -------- formulario\nconst review = ref('')\nconst rating = ref<number | null>(null)\nconst coverBase64 = ref<string | null>(null)\nconst success = ref(false)\nconst lastError = ref<string | null>(null)   // ← veremos aquí el mensaje del back\n\n// id BD desde query (hoisted -> sin TDZ)\nfunction getDbId(): string | null {\n  const q = route.query.dbId\n  if (Array.isArray(q)) return q[0] ?? null\n  return q != null ? String(q) : null\n}\nconst editingId = computed(getDbId)\n\n// id OpenLibrary normalizado\nconst openLibraryId = computed(() => {\n  const p = route.params.id as string | string[]\n  const s = Array.isArray(p) ? '/' + p.join('/') : String(p ?? '')\n  try { return decodeURIComponent(s) } catch { return s }\n})\n\ninterface BookDetail {\n  openLibraryId: string\n  title: string\n  author: string\n  year: number | null\n  cover: string | null\n}\n\n// PRE-FETCH: carga datos de la card + valores previos si es edición\nconst { data: book, pending, error } = useAsyncData<BookDetail>('bookDetail', async () => {\n  const q = route.query\n  const base: BookDetail = {\n    openLibraryId: openLibraryId.value,\n    title:  String(q.title  ?? ''),\n    author: String(q.author ?? ''),\n    year:   q.year != null ? Number(q.year) : null,\n    cover:  q.cover ? String(q.cover) : null,  // si viene desde Mi Biblioteca\n  }\n\n  const dbId = getDbId()\n  if (dbId) {\n    try {\n      // GET sobre tu back usando $api (NO /api/… con $fetch)\n      const existing = await $api<{ review?: string; rating?: number|null; coverBase64?: string|null }>(\n        `/books/my-library/${dbId}`,\n        { method: 'GET' }\n      )\n      review.value = String(existing?.review ?? '')\n      rating.value = existing?.rating ?? null\n      if (!base.cover && existing?.coverBase64) base.cover = existing.coverBase64\n    } catch (e) {\n      console.warn('No se pudo precargar desde la BD:', e)\n    }\n  }\n\n  // ❌ Importante: NO hagas ninguna llamada a front-cover si ese endpoint no existe en tu back.\n  return base\n})\n\n// portada a mostrar (primero la subida, luego la precargada)\nconst displayCover = computed(() => coverBase64.value || book.value?.cover || null)\n\nfunction fileToBase64(file: File) {\n  return new Promise<string>((resolve, reject) => {\n    const r = new FileReader()\n    r.onload = () => resolve(r.result as string)\n    r.onerror = reject\n    r.readAsDataURL(file)\n  })\n}\nasync function onUpload(e: Event) {\n  const i = e.target as HTMLInputElement\n  if (i.files && i.files[0]) coverBase64.value = await fileToBase64(i.files[0])\n}\n\nasync function save () {\n  lastError.value = null\n  success.value = false\n  if (!book.value) return\n\n  const body = {\n    openLibraryId: book.value.openLibraryId,\n    title:        book.value.title,\n    author:       book.value.author,\n    year:         book.value.year,\n    ...(coverBase64.value ? { coverBase64: coverBase64.value } : {}),\n    review:       review.value,\n    rating:       rating.value,\n  }\n\n  const isEdit = !!editingId.value\n  const path   = isEdit ? `/books/my-library/${editingId.value}` : `/books/my-library`\n  const method = isEdit ? 'PUT' : 'POST'\n\n  console.log('[DEBUG] baseURL debe verse arriba en consola al arrancar el app')\n  console.log('[DEBUG] SAVE →', method, path, body)\n\n  try {\n    // 👉 Esto va a http://localhost:3001/api + path (porque $api tiene baseURL '/api')\n    await $api(path, { method, body })\n    success.value = true\n  } catch (err: any) {\n    console.error('[SAVE ERROR]', err)\n    // ofetch suele poner info útil en err.data\n    lastError.value = err?.data?.message || err?.message || 'Error desconocido'\n  }\n}\n</script>\n\n<template>\n  <div class=\"grid\" style=\"gap:16px;\">\n    <div v-if=\"pending\" class=\"card\">Cargando…</div>\n    <div v-else-if=\"error\" class=\"card\">Error de precarga: {{ error.message }}</div>\n\n    <div v-else-if=\"book\" class=\"card\">\n      <div style=\"display:flex; gap:16px;\">\n        <img\n          v-if=\"displayCover\"\n          :src=\"displayCover\"\n          alt=\"portada\"\n          style=\"width:200px;aspect-ratio:2/3;object-fit:cover;border-radius:10px;\"\n        />\n        <div style=\"flex:1;\">\n          <h2 style=\"margin:0 0 6px;\">{{ book.title }}</h2>\n          <small class=\"muted\">\n            {{ book.author }}\n            <span v-if=\"book.year\">· {{ book.year }}</span>\n          </small>\n          <div style=\"margin-top:12px;\">\n            <input type=\"file\" @change=\"onUpload\" />\n            <small class=\"muted\"> Sube una portada (se guarda en base64)</small>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"card\">\n      <label>Review</label>\n      <textarea class=\"textarea\" v-model=\"review\" maxlength=\"500\" rows=\"6\"\n                placeholder=\"Escribe una reseña (máx 500)\" />\n      <label>Calificación</label>\n      <RatingStars v-model=\"rating\" />\n\n      <div style=\"display:flex;justify-content:flex-end;margin-top:12px;\">\n        <button class=\"button\" @click=\"save\">Guardar en Mi Biblioteca</button>\n      </div>\n\n      <div v-if=\"success\" style=\"margin-top:8px;color:#86efac;\">Guardado correctamente ✔</div>\n      <div v-else-if=\"lastError\" class=\"card\" style=\"margin-top:8px;color:#fca5a5;\">\n        Error del servidor: {{ lastError }}\n      </div>\n    </div>\n  </div>\n</template>\n"],"version":3}